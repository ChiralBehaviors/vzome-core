package com.vzome.core.zomic;

import antlr.RecognitionException;
import antlr.TokenStreamException;
import antlr.TokenStreamRecognitionException;
import com.vzome.core.algebra.AlgebraicNumber;
// Note that the com.vzome.core.antlr.generated classes can't be resolved after "clean"ing the project.
// They will be automatically re-generated by the build task and can then be resolved.
// To manually regenerate these classes without a complete build, run the gradle compileAntlrGrammars task.
import com.vzome.core.antlr.generated.ZomicLexer;
import com.vzome.core.antlr.generated.ZomicParser;
import com.vzome.core.antlr.generated.ZomicParserBaseListener;
import com.vzome.core.math.symmetry.Axis;
import com.vzome.core.math.symmetry.Direction;
import com.vzome.core.math.symmetry.IcosahedralSymmetry;
import com.vzome.core.render.ZomicEventHandler;
import com.vzome.core.zomic.parser.ErrorHandler;
import com.vzome.core.zomic.program.Build;
import com.vzome.core.zomic.program.Label;
import com.vzome.core.zomic.program.Move;
import com.vzome.core.zomic.program.Nested;
import com.vzome.core.zomic.program.Repeat;
import com.vzome.core.zomic.program.Save;
import com.vzome.core.zomic.program.Scale;
import com.vzome.core.zomic.program.Untranslatable;
import com.vzome.core.zomic.program.Visitor;
import com.vzome.core.zomic.program.Walk;
import com.vzome.core.zomic.program.ZomicStatement;
import java.util.Stack;
import org.antlr.v4.runtime.ANTLRInputStream;
import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.tree.ErrorNode;
import org.antlr.v4.runtime.tree.ParseTreeWalker;
import org.antlr.v4.runtime.tree.TerminalNode;

/**
 * Created by David Hall on 3/20/2015.
 */
public class ZomicASTCompiler
    extends ZomicParserBaseListener
{
	private final IcosahedralSymmetry symmetry;
	private final ZomicNamingConvention namingConvention ;
	private final Stack<ZomicStatement> statements = new Stack<>();
	private static boolean doPrint = true; // Only intended to be set from test methods

    public ZomicASTCompiler( IcosahedralSymmetry symm ) {
        symmetry = symm;
		namingConvention = new ZomicNamingConvention( symm );
    }

	public static Walk compile( CharStream input, IcosahedralSymmetry symm, boolean showProgressMessages ) {
        doPrint = showProgressMessages;
		ErrorHandler.Default errors = new ErrorHandler.Default();
		ZomicASTCompiler compiler = new ZomicASTCompiler(symm );
        Walk program = compiler.compile( input, errors );
		if( program != null ) {
			program.setErrors( errors.getErrors() );
		}
        return program;
    }
	
	public static Walk compile( String input, IcosahedralSymmetry symm, boolean showProgressMessages ) {
		return compile( new ANTLRInputStream( input ), symm, showProgressMessages );
	}
	
	public static Walk compile( String input, IcosahedralSymmetry symm ) {
		return compile( input, symm, false );
	}
	
	public Walk compile( CharStream input, ErrorHandler errors ) {
        try  {
            return compile( input );
        } catch( RecognitionException ex ) {
            errors.parseError( ex.getLine(), ex.getColumn(), ex.getMessage() );
        } catch (TokenStreamRecognitionException ex ) {
            RecognitionException re = ex.recog;
            errors.parseError( re.getLine(), re .getColumn(), re.getMessage() );
        } catch (TokenStreamException ex) {
            errors.parseError( ErrorHandler.UNKNOWN, ErrorHandler.UNKNOWN, ex.getMessage() );
        }		
        return null;
    }

	protected void reset() {
		tabs = 0; 
		statements.clear(); 		
	}
	
	protected Walk compile( CharStream inputStream )
		throws RecognitionException, TokenStreamException {
		reset(); // in case a single instance compiles more than one program
		
		// feed input to lexer
        ZomicLexer lexer = new ZomicLexer( inputStream );
		// get a stream of matched tokens
		CommonTokenStream tokens = new CommonTokenStream(lexer);
		// pass tokens to the parser
        ZomicParser parser = new ZomicParser( tokens );

		// specify our entry point (top level rule)
 		ZomicParser.ProgramContext program = parser.program(); // parse
		
		// Use the DEFAULT walker to walk from the entry point with this listener attached.
		// In the process, the enter and exit methods of this class will be invoked to populate the statements collection.
        ParseTreeWalker.DEFAULT.walk(this, program);
		
		// Now we return the statement(s) collected by the listener.
		return getProgram();
	}
	
	protected Walk getProgram() {
		return statements.size() == 0 
				? null
				: (Walk) statements.firstElement();
	}
	
	protected static int parseInt( Token token ) {
		return Integer.parseInt( token.getText() );
	}

	protected void prepare( ZomicStatement statement) {
		statements.push(statement);
	}
	
	protected void commmitLast() {
		commit(statements.pop());
	}
			
	protected void commit(ZomicStatement newStatement)	{
		ZomicStatement currentStatement = statements.peek();
		if ( currentStatement instanceof Walk ) {
			((Walk) currentStatement).addStatement( newStatement );
		} else {
			((Nested) currentStatement).setBody( newStatement );
		}
	}

	private int tabs = 0;
	private void showTabs(boolean add) 	{
		if(doPrint) { 
			if(!add) { tabs--; }
			for( int i = 0; i < tabs; i++)
			{
				print("   ");
			}
			if(add) { tabs++; }
		}
	}

	protected void printContext(ParserRuleContext ctx, boolean isEntering) 	{ 
		if(!doPrint) { return; }
		showTabs(isEntering);
		String contextName = ctx.getClass().getSimpleName();
		String strContext = "Context";
		if(contextName.endsWith(strContext)) {
			// strip "Context" from the name for readability
			contextName = contextName.substring(0, contextName.length() - strContext.length());
		}
		println((isEntering ? "--> " : "<-- ") + contextName);
	}

	protected static void print(String msg) {
		if(doPrint && msg != null) {
			System.out.print(msg);
		}
	}

	protected static void println(String msg) {
		if(doPrint && msg != null) {
			System.out.println(msg);
		}
	}

/* 
******************************************************
* BEGIN ZomicStatementTemplate and supporting classes 
******************************************************
*/

	protected interface IGenerateZomicStatement<T extends ZomicStatement> {
		abstract T generate();
		abstract T generate(IcosahedralSymmetry symmetry);
	}
	
	protected abstract class ZomicStatementTemplate<T extends ZomicStatement> 
		extends ZomicStatement
		implements IGenerateZomicStatement<T> {

		@Override
		public void accept(Visitor visitor) throws ZomicException {
			String msg = this.getClass().getSimpleName() + 
					" does not accept visitors. It is only a template used for compiling Zomic Parse trees to other ZomicStatement derived classes.";
			throw new UnsupportedOperationException( msg );
		}

		@Override
		public T generate() {
			String msg = this.getClass().getSimpleName() +
					".generate() is not implemented. Try overriding it or use this.generate(IcosahedralSymmetry symmetry).";
			throw new UnsupportedOperationException(  msg );
		}
		
		@Override
		public T generate(IcosahedralSymmetry symmetry) {
			String msg = this.getClass().getSimpleName() + 
					".generate(IcosahedralSymmetry symmetry) is not implemented. Try overriding it or use this.generate().";
			throw new UnsupportedOperationException( msg );
		}
	}

	
	protected interface IHaveAlgebraicNumberInfo {
		int ones();
		void ones(int i);

		int phis();
		void phis(int i);
		
		AlgebraicNumberInfo getAlgebraicNumberInfo();
	}

	protected class AlgebraicNumberInfo
		implements IHaveAlgebraicNumberInfo 
	{
		private int ones = 1;
		@Override public int ones() { return ones; }
		@Override public void ones(int i) { ones = i; }
		
		private int phis = 0;
		@Override public int phis() { return phis; }
		@Override public void phis(int i) { phis = i; }

		AlgebraicNumber generate(IcosahedralSymmetry symmetry) {
			return symmetry.getField().createAlgebraicNumber( ones, phis, 1, 1 );
		}

		@Override
		public AlgebraicNumberInfo getAlgebraicNumberInfo() {
			return this;
		}
	}

	private void setCurrentScale(int scale) { 
		((IHaveStrutLengthInfo)statements.peek()).scale(scale);
	}

	protected interface IHaveScaleInfo 
		extends IHaveAlgebraicNumberInfo 
	{
		int scale();
		void scale( int i );
	}

	protected class ScaleInfo 
		extends AlgebraicNumberInfo
		implements IHaveScaleInfo
	 {
		private int scale = 1;
		@Override public int scale() { return scale; }
		@Override public void scale(int i) { scale = i; }
	}
	
	protected interface IHaveStrutLengthInfo 
		extends IHaveScaleInfo
	{
		int denominator();
		void denominator(int i);

		String sizeRef();
		void sizeRef(String s);
		
		boolean isVariableLength();
		void isVariableLength(boolean is);
	}

	protected class StrutLengthInfo
			extends ScaleInfo
			implements IHaveStrutLengthInfo 
	{
		private int denominator = 1;
		@Override public int denominator() { return denominator; }
		@Override public void denominator(int i) { denominator = i; }

		private String sizeRef = null;
		@Override public String sizeRef() { return sizeRef; }
		@Override public void sizeRef(String s)  { sizeRef = s; }

		public StrutLengthInfo() {
			scale(ZomicNamingConvention.MEDIUM);
		}

		private boolean isVariableLength = false;
		@Override public boolean isVariableLength() { 
			return ( isVariableLength	// DJH New proposed alternative to size -99
					|| (-99 == scale())	// old variable size flag used only internally by strut resources.
					); 
		}
		@Override public void isVariableLength(boolean is)  { isVariableLength = is; }

		AlgebraicNumber generate(IcosahedralSymmetry symmetry, String axisColor) {
			// validate 
			if ( denominator != 1 ) {
				Direction direction = symmetry.getDirection(axisColor);
				if ( direction == null || ! direction.hasHalfSizes()) {
					String msg = "half struts are not allowed on '" + axisColor + "' axes.";
					println(msg);
					throw new RuntimeException( msg );
				}
			} 
			// Zero is the "variable" length indicator. Used only by internal core strut resources
			if (isVariableLength()) { 
				return symmetry.getField().zero();
			}
			// adjustments per color
			int lengthFactor = 1;
			int scaleOffset = 0;
			switch (axisColor) {
				case "blue":
					lengthFactor = 2;
					break;
				case "green":
					lengthFactor = 2;
					break;
				case "yellow":
					scaleOffset = -1;
					break;
				case "purple":
					scaleOffset = -1;
					break;
				default:
					break;
			}
			// calculate
			return symmetry.getField().createAlgebraicNumber( 
					ones() * lengthFactor, 
					phis() * lengthFactor, 
					denominator, 
					scale() + scaleOffset);
		}
	}

	protected interface IHaveAxisInfo {
										// e.g. red -2+
		String axisColor();				// red
		void axisColor(String s);
		
		String indexNumber();			// -2
		void indexNumber(String s);

		String handedness();			// +
		void handedness(String s);
		
		String indexFullName();			// -2+

		AxisInfo getAxisInfo();
	}

	protected class AxisInfo 
		implements IHaveAxisInfo
	{
		private String axisColor = "";
		private String indexNumber = "";
		private String handedness = "";

		Axis generate() {
			try {
				// TODO: move this check into a unit test instead of a runtime check.
				Axis axis = namingConvention.getAxis(axisColor, indexFullName() );
				String check = namingConvention.getName( axis );
				if ( axis != namingConvention.getAxis(axisColor, check ) ) {
					println( axisColor + " " + indexFullName() + " mapped to " + check );
				}
				return axis;
			} catch( RuntimeException ex ) {
				throw new RuntimeException( "bad axis specification: '" + axisColor + " " + indexFullName() + "'", ex);
			}
		}

		@Override
		public String axisColor() { return axisColor; }
		@Override
		public void axisColor(String s) { axisColor = s; }

		@Override
		public String indexNumber() { return indexNumber; }
		@Override
		public void indexNumber(String s) { indexNumber = s; }

		@Override
		public String handedness() { return handedness; }
		@Override
		public void handedness(String s) { handedness = s; }

		@Override
		public String indexFullName() { return indexNumber + handedness; }
		
		@Override
		public AxisInfo getAxisInfo() { return this; }
	}

	protected class MoveTemplate 
		extends ZomicStatementTemplate<Move>
		implements IHaveStrutLengthInfo, IHaveAxisInfo {
	
		private final StrutLengthInfo strutLengthInfo = new StrutLengthInfo();
		private final AxisInfo axisInfo = new AxisInfo();

		@Override
		public Move generate(IcosahedralSymmetry symmetry) {
			Axis axis = axisInfo.generate();
			AlgebraicNumber strutLength = strutLengthInfo.generate(symmetry, axisColor());
			return new Move(axis, strutLength);
		}

		@Override
		public int denominator() { return strutLengthInfo.denominator; }
		@Override
		public void denominator(int i) { strutLengthInfo.denominator = i; }

		@Override
		public String sizeRef() { return strutLengthInfo.sizeRef; }
		@Override
		public void sizeRef(String s) { strutLengthInfo.sizeRef = s;}
		
		@Override
		public boolean isVariableLength() { return strutLengthInfo.isVariableLength; }
		@Override
		public void isVariableLength(boolean is) { strutLengthInfo.isVariableLength = is;}
		

		@Override
		public int scale() { return strutLengthInfo.scale(); }
		@Override
		public void scale(int i) { strutLengthInfo.scale(i); }

		@Override
		public int ones() { return strutLengthInfo.ones(); }
		@Override
		public void ones(int i) {
			strutLengthInfo.ones(i);
		}

		@Override
		public int phis() { return strutLengthInfo.phis(); }
		@Override
		public void phis(int i) { strutLengthInfo.phis(i); }

		@Override
		public String axisColor() { return axisInfo.axisColor; }
		@Override
		public void axisColor(String s) { axisInfo.axisColor(s); }
		
		@Override
		public String indexNumber() { return axisInfo.indexNumber; }
		@Override
		public void indexNumber(String s) { axisInfo.indexNumber(s); }
		@Override

		public String handedness() { return axisInfo.handedness; }
		@Override
		public void handedness(String s) { axisInfo.handedness(s); }


		@Override
		public String indexFullName() { return axisInfo.indexFullName(); }

		@Override
		public AxisInfo getAxisInfo() {
			return axisInfo;
		}

		@Override
		public AlgebraicNumberInfo getAlgebraicNumberInfo() {
			return strutLengthInfo.getAlgebraicNumberInfo();
		}
	}

	protected class ScaleTemplate 
		extends ZomicStatementTemplate<Scale>
		implements IHaveScaleInfo {
	
		private final ScaleInfo scaleInfo = new ScaleInfo();

		@Override
		public Scale generate() {
			return new Scale(scaleInfo.generate(symmetry));
		}

		@Override
		public int scale() { return scaleInfo.scale(); }
		@Override
		public void scale(int i) { scaleInfo.scale(i); }

		@Override
		public int ones() { return scaleInfo.ones(); }
		@Override
		public void ones(int i) {
			scaleInfo.ones(i);
		}

		@Override
		public int phis() { return scaleInfo.phis(); }
		@Override
		public void phis(int i) { scaleInfo.phis(i); }

		@Override
		public AlgebraicNumberInfo getAlgebraicNumberInfo() {
			return scaleInfo.getAlgebraicNumberInfo();
		}
	}

/* 
**********************************
* BEGIN Overriding Event Handlers 
**********************************
*/
	
	@Override public void enterProgram(ZomicParser.ProgramContext ctx) { 
		prepare( new Walk() );
	}
	
	@Override public void exitProgram(ZomicParser.ProgramContext ctx) { 
		if(!(statements.firstElement() instanceof Walk)) {
			throw new RuntimeException("We should always have a Walk by the time we get here!");		
		}
	}
	
	//@Override public void enterStmt(ZomicParser.StmtContext ctx) { }
	//@Override public void exitStmt(ZomicParser.StmtContext ctx) { }

	//@Override public void enterCompound_stmt(ZomicParser.Compound_stmtContext ctx) { }
	//@Override public void exitCompound_stmt(ZomicParser.Compound_stmtContext ctx) { }
	
	@Override public void enterDirectCommand(ZomicParser.DirectCommandContext ctx) { 
		prepare( new Walk() );
	}
	
	@Override public void exitDirectCommand(ZomicParser.DirectCommandContext ctx) {
		commmitLast();
	}
	
	@Override public void enterNestedCommand(ZomicParser.NestedCommandContext ctx) { 
		prepare( new Walk() );
	}
	
	@Override public void exitNestedCommand(ZomicParser.NestedCommandContext ctx) {
		commmitLast();
	}
	
	@Override public void enterStrut_stmt(ZomicParser.Strut_stmtContext ctx) { 
		prepare( new MoveTemplate() );
	}
	
	@Override public void exitStrut_stmt(ZomicParser.Strut_stmtContext ctx) { 
		MoveTemplate template = (MoveTemplate) statements.pop();
		commit (template.generate(symmetry));
	}
	
	//@Override public void enterLabel_stmt(ZomicParser.Label_stmtContext ctx) { }
	
	@Override public void exitLabel_stmt(ZomicParser.Label_stmtContext ctx) {
		commit( new Label(ctx.IDENT().getText() ) );
	}
	
	@Override public void enterScale_stmt(ZomicParser.Scale_stmtContext ctx) {
		prepare(new ScaleTemplate());
	}
	
	@Override public void exitScale_stmt(ZomicParser.Scale_stmtContext ctx) {
		ScaleTemplate template = (ScaleTemplate) statements.pop();
		commit (template.generate());
	}

	//@Override public void enterBuild_stmt(ZomicParser.Build_stmtContext ctx) { }
	
	@Override public void exitBuild_stmt(ZomicParser.Build_stmtContext ctx) { 
		commit( new Build(/*build*/ true, /*destroy*/ false) );
	}
	
	//@Override public void enterDestroy_stmt(ZomicParser.Destroy_stmtContext ctx) { }
	
	@Override public void exitDestroy_stmt(ZomicParser.Destroy_stmtContext ctx) { 
		commit( new Build(/*build*/ false, /*destroy*/ true) );
	}
	
	//@Override public void enterMove_stmt(ZomicParser.Move_stmtContext ctx) { }
	
	@Override public void exitMove_stmt(ZomicParser.Move_stmtContext ctx) { 
		commit( new Build(/*build*/ false, /*destroy*/ false) );
	}
	
//	@Override public void enterRotate_stmt(ZomicParser.Rotate_stmtContext ctx) {
//		prepare(new RotateTemplate());
//	}
//	
//	@Override public void exitRotate_stmt(ZomicParser.Rotate_stmtContext ctx) {
//		RotateTemplate template = (RotateTemplate) statements.pop();
//		commit (template.generate());
//	}
	
//	@Override public void enterReflect_stmt(ZomicParser.Reflect_stmtContext ctx) {
//		prepare(new ReflectTemplate());
//	}
//	
//	@Override public void exitReflect_stmt(ZomicParser.Reflect_stmtContext ctx) {
//		ReflectTemplate template = (ReflectTemplate) statements.pop();
//		commit (template.generate());
//	}
	
	//@Override public void enterFrom_stmt(ZomicParser.From_stmtContext ctx) { }
	
	@Override public void exitFrom_stmt(ZomicParser.From_stmtContext ctx) {
		commit( new Save(ZomicEventHandler.ACTION) );
		commit( new Walk() );
	}
	
//	@Override public void enterSymmetry_stmt(ZomicParser.Symmetry_stmtContext ctx) {
//		prepare(new SymmetryTemplate());
//	}
//	
//	@Override public void exitSymmetry_stmt(ZomicParser.Symmetry_stmtContext ctx) {
//		SymmetryTemplate template = (SymmetryTemplate) statements.pop();
//		commit (template.generate());
//	}
	
	//@Override public void enterRepeat_stmt(ZomicParser.Repeat_stmtContext ctx) { }
	
	@Override public void exitRepeat_stmt(ZomicParser.Repeat_stmtContext ctx) {
		commit( new Repeat(parseInt(ctx.count)) );
	}
	
	//@Override public void enterBranch_stmt(ZomicParser.Branch_stmtContext ctx) { }
	
	@Override public void exitBranch_stmt(ZomicParser.Branch_stmtContext ctx) {
		commit( new Save(ZomicEventHandler.LOCATION) );
	}
	
	//@Override public void enterSave_stmt(ZomicParser.Save_stmtContext ctx) { }
	
	@Override public void exitSave_stmt(ZomicParser.Save_stmtContext ctx) {
		int state = 0;
		switch(ctx.state.getText()) {
			case "orientation":
				state = ZomicEventHandler.ORIENTATION;
				break;
			case "scale":
				state = ZomicEventHandler.SCALE;
				break;
			case "location":
				state = ZomicEventHandler.LOCATION;
				break;
			case "build":
				state = ZomicEventHandler.ACTION;
				break;
			case "all":
				state = ZomicEventHandler.ALL;
				break;
			default:
				throw new UnsupportedOperationException("Unexpected save parameter: " + ctx.getText());
		}
		commit( new Save(state) );
	}
	
	//@Override public void enterSymmetry_center_expr(ZomicParser.Symmetry_center_exprContext ctx) { }
	
	//@Override public void exitSymmetry_center_expr(ZomicParser.Symmetry_center_exprContext ctx) { }
	
	//@Override public void enterStrut_length_expr(ZomicParser.Strut_length_exprContext ctx) { }
	
	@Override public void exitStrut_length_expr(ZomicParser.Strut_length_exprContext ctx) { 
		if(ctx.HALF() != null) {
			((IHaveStrutLengthInfo)statements.peek()).denominator(2);
		}
	}
	
	//@Override public void enterHalf_size_expr(ZomicParser.Half_size_exprContext ctx) { }
	
	//@Override public void exitHalf_size_expr(ZomicParser.Half_size_exprContext ctx) { }
	
	//@Override public void enterSize_expr(ZomicParser.Size_exprContext ctx) { }
	
	//@Override public void exitSize_expr(ZomicParser.Size_exprContext ctx) { }
	
	//@Override public void enterExplicit_size_expr(ZomicParser.Explicit_size_exprContext ctx) { }
	
	@Override public void exitExplicit_size_expr(ZomicParser.Explicit_size_exprContext ctx) { 
		if( ctx.scale != null ) {
			setCurrentScale(parseInt(ctx.scale));
		}
		IHaveStrutLengthInfo strutLengthInfo = (IHaveStrutLengthInfo)statements.peek();
		if( ctx.sizeRef != null ) {
			String sizeRef = ctx.sizeRef.getText();
			strutLengthInfo.sizeRef(sizeRef);
			println("Ignoring undocumented sizeRef = '" + sizeRef + "'.");
		}
		if( ctx.isVariableLength != null ) {
			strutLengthInfo.isVariableLength(true);
		}
	}
	
	@Override public void exitSizeShort(ZomicParser.SizeShortContext ctx) { 
		setCurrentScale(ZomicNamingConvention.SHORT);
	}
	
	@Override public void exitSizeLong(ZomicParser.SizeLongContext ctx) { 
		setCurrentScale(ZomicNamingConvention.LONG);
	}
	
	@Override public void exitSizeMedium(ZomicParser.SizeMediumContext ctx) { 
		setCurrentScale(ZomicNamingConvention.MEDIUM);
	}
	
	//@Override public void enterAxis_expr(ZomicParser.Axis_exprContext ctx) { }
	
	//@Override public void exitAxis_expr(ZomicParser.Axis_exprContext ctx) { }
	
	//@Override public void enterAxis_index_expr(ZomicParser.Axis_index_exprContext ctx) { }
	
	@Override public void exitAxis_index_expr(ZomicParser.Axis_index_exprContext ctx) {
		AxisInfo elements = ((IHaveAxisInfo)statements.peek()).getAxisInfo();
		elements.indexNumber = ctx.indexNumber.getText();
		if ( ctx.handedness != null ) { 
			elements.handedness = ctx.handedness.getText();
		}
	}
	
	//@Override public void enterAxis_name_expr(ZomicParser.Axis_name_exprContext ctx) { }

	/*
	 This convoluted looking code allows new colors and color aliases 
	 to be added to the language without overriding the event handler for each specific color.
	 It's a bit of overkill, but it's nice because it handles aliases automaatically. 
	 e.g. "pent" is an alias for "red". This mechanism handles translating the aliases.
	 The test for ending with strCONTEXT is to avoid using ErrorNodeImpl 
	 as when we parse an invalid color or some other unforeseen invalid context.
	*/
	@Override public void exitAxis_name_expr(ZomicParser.Axis_name_exprContext ctx) {
		final String strCONTEXT = "context";
		String colorContext = "Unexpected Axis Color: '" + ctx.getText() + "'.";
		if(ctx.children != null) {
			colorContext = ctx.getChild(0).getClass().getSimpleName().toLowerCase();
			if(colorContext.endsWith(strCONTEXT)) {
				colorContext = colorContext.replaceFirst(strCONTEXT, "");
				((IHaveAxisInfo)statements.peek()).axisColor(colorContext);
				println(colorContext);
				return;
			}
		} 
		println(colorContext);
		throw new RuntimeException( colorContext );
	} 

	@Override public void exitAlgebraic_number_expr(ZomicParser.Algebraic_number_exprContext ctx) { 
		AlgebraicNumberInfo template = ((IHaveAlgebraicNumberInfo)statements.peek()).getAlgebraicNumberInfo();
		template.ones = parseInt(ctx.ones);
		if(ctx.phis != null) {
			template.phis =  parseInt(ctx.phis);
		}
	}
	
	@Override public void enterEveryRule(ParserRuleContext ctx) { 
		printContext(ctx, true);
	}
	
	@Override public void exitEveryRule(ParserRuleContext ctx) { 
		printContext(ctx, false);
	}
	
	@Override public void visitTerminal(TerminalNode node) { 
		//println("visitTerminal");
	}
	
	@Override public void visitErrorNode(ErrorNode node) { 
		String msg = node.getText();
		// TODO: Provide a list of expected tokens 
		// by catching a RecognitionException in the parser and using parser.getExpectedTokens()...
		// See http://stackoverflow.com/questions/25512770/antlr4-get-next-possible-matching-parser-rules-for-the-given-input
		// or "Altering and Redirecting ANTLR Error Messages" from section 9.2 of "The Definitive ANTLR 4 Reference"
		println("visitErrorNode: " + msg);
		commit( new Untranslatable(msg) );
	}

}
